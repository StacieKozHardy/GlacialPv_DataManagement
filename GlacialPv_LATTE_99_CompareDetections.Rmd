---
title: "LATTE Methods Comparison"
author: "Stacie Hardy"
date: "Date Created: `r format(Sys.time(), '%m/%d/%Y')`"
output: pdf_document

knit: (function(inputFile, encoding) { 
  rmarkdown::render(
    inputFile, 
    encoding = encoding, 
    output_file = file.path(dirname(inputFile), 'LATTE_Evaluation_20221128.pdf'))
  })
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warnings = FALSE)

# Create functions -----------------------------------------------
# Function to install packages needed
install_pkg <- function(x)
  {
  if (!require(x,character.only = TRUE))
    {
    install.packages(x,dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
    }
  }

merge_and_intersect <- function(matchWhat, toWhat, method) {
  matchWhat_var <- deparse(substitute(matchWhat))
  toWhat_var <- deparse(substitute(toWhat))
  
  data <- matchWhat %>%
    full_join (toWhat, by = setNames(paste0(toWhat_var, "_image_name"), paste0(matchWhat_var, "_image_name"))) %>%
    mutate(image_name = ifelse(
      is.na(!!as.name(paste0(matchWhat_var, "_image_name"))), 
      !!as.name(paste0(toWhat_var, "_image_name")), 
      !!as.name(paste0(matchWhat_var, "_image_name")))) %>%
    mutate(intersect_LR = ifelse(!!as.name(paste0(matchWhat_var, "_bound_right")) < !!as.name(paste0(toWhat_var, "_bound_left")) |
                                   !!as.name(paste0(matchWhat_var, "_bound_left")) > !!as.name(paste0(toWhat_var, "_bound_right")), "no", "yes"),
           intersect_TB = ifelse(!!as.name(paste0(matchWhat_var, "_bound_top")) > !!as.name(paste0(toWhat_var, "_bound_bottom")) |
                                   !!as.name(paste0(matchWhat_var, "_bound_bottom")) < !!as.name(paste0(toWhat_var, "_bound_top")), "no", "yes"))

  if(method == "minimum_distance") {
    intersecting <- data %>%
      filter(intersect_LR == "yes" & intersect_TB == "yes") %>%
      mutate(distance = sqrt(
        ((!!as.name(paste0(matchWhat_var, "_average_x")) - !!as.name(paste0(toWhat_var, "_average_x"))) ^ 2) + 
          ((!!as.name(paste0(matchWhat_var, "_average_y")) - !!as.name(paste0(toWhat_var, "_average_y"))) ^ 2)) ) %>%
      group_by(image_name, !!as.name(paste0(matchWhat_var, "_id"))) %>%
      slice(which.min(distance)) %>%
      filter(distance < 50) %>%
      select(image_name, paste0(matchWhat_var, "_id"), paste0(toWhat_var, "_id"), distance) %>%
      ungroup()
  } else if (method == "maximum_score") {
    intersecting <- data %>%
      filter(intersect_LR == "yes" & intersect_TB == "yes") %>%
      group_by(image_name, !!as.name(paste0(matchWhat_var, "_id"))) %>%
      slice(which.max(!!as.name(paste0(toWhat_var, "_score")))) %>%
      select(image_name, paste0(matchWhat_var, "_id"), paste0(toWhat_var, "_id"), paste0(toWhat_var, "_score")) %>%
      ungroup()
  }
}

process_mnC <- function(file_folder, file_allrgb_manual) {
  mnC <- read.csv(paste(file_folder, file_allrgb_manual, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                              "score", "length", "detection_type", "type_score", "att1", "att2")) %>%
    data.frame(stringsAsFactors = FALSE) %>%
    mutate(image_name = basename(image_name)) %>%
    filter(detection_type == "harbor_seal" | detection_type == "split_harbor_seal") %>%
    select(detection, image_name, bound_left, bound_top, bound_right, bound_bottom, detection_type) %>%
    mutate(average_x = (bound_left + bound_right)/2,
           average_y = (bound_top + bound_bottom)/2) %>%
    rename_with( ~ paste0("mnC_", .x))
}

process_mnT <- function(file_folder, file_ir2rgb_manual_C, file_ir2rgb_manual_L, file_ir2rgb_manual_R) {
  mnT <- read.csv(paste(file_folder, file_ir2rgb_manual_C, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                              "score", "length", "detection_type", "type_score", "att1", "att2")) %>%
    rbind(read.csv(paste(file_folder, file_ir2rgb_manual_L, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                   col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                                 "score", "length", "detection_type", "type_score", "att1", "att2"))) %>%
    rbind(read.csv(paste(file_folder, file_ir2rgb_manual_R, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                   col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                                 "score", "length", "detection_type", "type_score", "att1", "att2"))) %>%
    data.frame(stringsAsFactors = FALSE) %>%
    mutate(image_name = basename(image_name)) %>%
    filter(detection_type == "harbor_seal" | detection_type == "split_harbor_seal" | detection_type ==
             "harbor_seal_partial") %>% #| detection_type == "harbor_seal_offThermal" |  detection_type == "off_ir") %>%
    select(detection, image_name, bound_left, bound_top, bound_right, bound_bottom, detection_type) %>%
    mutate(average_x = (bound_left + bound_right)/2,
           average_y = (bound_top + bound_bottom)/2) %>%
    rename_with( ~ paste0("mnT_", .x))
}

process_mdC <- function(file_folder, file_ir2rgb_rgb_model_C, file_ir2rgb_rgb_model_L, file_ir2rgb_rgb_model_R) {
  mdC <- read.csv(paste(file_folder, file_ir2rgb_rgb_model_C, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                            "score", "length", "detection_type", "type_score", "att1", "att2")) %>%
    rbind(read.csv(paste(file_folder, file_ir2rgb_rgb_model_L, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                   col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                                 "score", "length", "detection_type", "type_score", "att1", "att2"))) %>%
    rbind(read.csv(paste(file_folder, file_ir2rgb_rgb_model_R, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                   col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                                 "score", "length", "detection_type", "type_score", "att1", "att2"))) %>%
    data.frame(stringsAsFactors = FALSE) %>%
    mutate(image_name = basename(image_name)) %>%
    filter(detection_type == "harbor_seal" | detection_type == "split_harbor_seal") %>%
    select(detection, image_name, bound_left, bound_top, bound_right, bound_bottom, detection_type) %>%
    mutate(average_x = (bound_left + bound_right)/2,
           average_y = (bound_top + bound_bottom)/2) %>%
    rename_with( ~ paste0("mdC_", .x))
}

process_mdT <- function(file_folder, file_ir2rgb_ir_model_C, file_ir2rgb_ir_model_L, file_ir2rgb_ir_model_R) {
  mdT <- read.csv(paste(file_folder, file_ir2rgb_ir_model_C, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                              "score", "length", "detection_type", "type_score", "att1", "att2")) %>%
    rbind(read.csv(paste(file_folder, file_ir2rgb_ir_model_L, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                   col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                                 "score", "length", "detection_type", "type_score", "att1", "att2"))) %>%
    rbind(read.csv(paste(file_folder, file_ir2rgb_ir_model_R, sep = "/"), skip = 2, header = FALSE, stringsAsFactors = FALSE, 
                   col.names = c("detection", "image_name", "frame_number", "bound_left", "bound_top", "bound_right", "bound_bottom", 
                                 "score", "length", "detection_type", "type_score", "att1", "att2"))) %>%
    data.frame(stringsAsFactors = FALSE) %>%
    mutate(image_name = basename(image_name)) %>%
    filter(detection_type == "harbor_seal" | detection_type == "split_harbor_seal") %>%
    select(detection, image_name, bound_left, bound_top, bound_right, bound_bottom, detection_type) %>%
    mutate(average_x = (bound_left + bound_right)/2,
           average_y = (bound_top + bound_bottom)/2) %>%
    rename_with( ~ paste0("mdT_", .x))
}

# Install libraries ----------------------------------------------
install_pkg("tidyverse")
install_pkg("RPostgreSQL")
install_pkg("RColorBrewer")
install_pkg("ggbreak")

# Get unprocessed RGB images
con <- RPostgreSQL::dbConnect(PostgreSQL(), 
                              dbname = Sys.getenv("pep_db"), 
                              host = Sys.getenv("pep_ip"), 
                              user = Sys.getenv("pep_admin"), 
                              password = Sys.getenv("admin_pw"))

unprocessed_rgb <- RPostgreSQL::dbGetQuery(con, paste("SELECT image_name FROM surv_pv_gla.tbl_images_4processing_latte WHERE image_survey_id = \'columbia_20200909_sample_1\' AND image_type = \'rgb_image\' AND
                                                      (ir_nuc = \'Y\' 
                                                      OR 
                                                      image_name IN (SELECT rgb_image_name FROM surv_pv_gla.summ_data_inventory WHERE ir_image = \'N\'))",
                                                      sep = "")) %>%
  rbind(RPostgreSQL::dbGetQuery(con, paste("SELECT image_name FROM surv_pv_gla.tbl_images_4processing_latte WHERE image_survey_id = \'dbay_20200904_sample_1\' AND image_type = \'rgb_image\' AND
                                                      (ir_nuc = \'Y\' 
                                                      OR 
                                                      image_name IN (SELECT rgb_image_name FROM surv_pv_gla.summ_data_inventory WHERE ir_image = \'N\'))",
                                                      sep = ""))) %>%
  mutate(unprocessed = "TRUE")

RPostgreSQL::dbDisconnect(con)
rm(con)

# Set columbia_20200909_sample_1 variables
file_folder_columbia <- "\\\\akc0ss-n086\\NMML_Polar_Imagery\\Surveys_HS\\Glacial\\Projects\\Surveys Glacial Sites Counts\\2020\\columbia_20200909_sample_1"

# file_allrgb_model_columbia <- "columbia_20200909_sample_1_all_rgb_detections_20220426_processed.csv" 
file_ir2rgb_ir_model_C_columbia <- "columbia_20200909_sample_1_C_trigger_detectionsIR_20220426_processed_transposedRGB.csv"
file_ir2rgb_ir_model_L_columbia <- "columbia_20200909_sample_1_L_trigger_detectionsIR_20220426_processed_transposedRGB.csv"
file_ir2rgb_ir_model_R_columbia <- "columbia_20200909_sample_1_R_trigger_detectionsIR_20220426_processed_transposedRGB.csv"
file_ir2rgb_rgb_model_C_columbia <- "columbia_20200909_sample_1_C_trigger_detectionsRGB_20220426_processed.csv"
file_ir2rgb_rgb_model_L_columbia <- "columbia_20200909_sample_1_L_trigger_detectionsRGB_20220426_processed.csv"
file_ir2rgb_rgb_model_R_columbia <- "columbia_20200909_sample_1_R_trigger_detectionsRGB_20220426_processed.csv"
file_allrgb_manual_columbia <- "columbia_20200909_sample_1_all_rgb_manual_review_20220426.csv"
file_ir2rgb_manual_C_columbia <- "columbia_20200909_sample_1_C_ir-rgb_manualReview_rgbDetections_20220909.csv"
file_ir2rgb_manual_L_columbia <- "columbia_20200909_sample_1_L_ir-rgb_manualReview_rgbDetections_20220912.csv"
file_ir2rgb_manual_R_columbia <- "columbia_20200909_sample_1_R_ir-rgb_manualReview_rgbDetections_20220912.csv"

# Set dbay_20200904_sample_1 variables
file_folder_dbay <- "\\\\akc0ss-n086\\NMML_Polar_Imagery\\Surveys_HS\\Glacial\\Projects\\Surveys Glacial Sites Counts\\2020\\dbay_20200904_sample_1"

# file_allrgb_model_dbay <- "dbay_20200904_sample_1_all_rgb_detections_20220426_processed.csv" # not using for DBay
file_ir2rgb_ir_model_C_dbay <- "dbay_20200904_sample_1_C_trigger_detectionsIR_20220426_processed_transposedRGB.csv"
file_ir2rgb_ir_model_L_dbay <- "dbay_20200904_sample_1_L_trigger_detectionsIR_20220426_processed_transposedRGB.csv"
file_ir2rgb_ir_model_R_dbay <- "dbay_20200904_sample_1_R_trigger_detectionsIR_20220426_processed_transposedRGB.csv"
file_ir2rgb_rgb_model_C_dbay <- "dbay_20200904_sample_1_C_trigger_detectionsRGB_20220426_processed.csv"
file_ir2rgb_rgb_model_L_dbay <- "dbay_20200904_sample_1_L_trigger_detectionsRGB_20220426_processed.csv"
file_ir2rgb_rgb_model_R_dbay <- "dbay_20200904_sample_1_R_trigger_detectionsRGB_20220426_processed.csv"
file_allrgb_manual_dbay <- "dbay_20200904_sample_1_all_rgb_manualReview_20220916_final.csv"
file_ir2rgb_manual_C_dbay <- "dbay_20200904_sample_1_C_ir-rgb_manualReview_rgbDetections_20220810.csv"
file_ir2rgb_manual_L_dbay <- "dbay_20200904_sample_1_L_ir-rgb_manualReview_rgbDetections_20220908.csv"
file_ir2rgb_manual_R_dbay <- "dbay_20200904_sample_1_R_ir-rgb_manualReview_rgbDetections_20220912.csv"

# Process manual and model data
mnC <- process_mnC(file_folder_columbia, file_allrgb_manual_columbia) %>%
  rbind(process_mnC(file_folder_dbay, file_allrgb_manual_dbay)) %>%
  mutate(mnC_id = row_number()) 

mnT <- process_mnT(file_folder_columbia, file_ir2rgb_manual_C_columbia, file_ir2rgb_manual_L_columbia, file_ir2rgb_manual_R_columbia) %>%
  rbind(process_mnT(file_folder_dbay, file_ir2rgb_manual_C_dbay, file_ir2rgb_manual_L_dbay, file_ir2rgb_manual_R_dbay)) %>%
  mutate(mnT_id = row_number()) 

mdC <- process_mdC(file_folder_columbia, file_ir2rgb_rgb_model_C_columbia, file_ir2rgb_rgb_model_L_columbia, file_ir2rgb_rgb_model_R_columbia) %>%
  rbind(process_mdC(file_folder_dbay, file_ir2rgb_rgb_model_C_dbay, file_ir2rgb_rgb_model_L_dbay, file_ir2rgb_rgb_model_R_dbay)) %>%
  mutate(mdC_id = row_number()) 

mdT <- process_mdT(file_folder_columbia, file_ir2rgb_ir_model_C_columbia, file_ir2rgb_ir_model_L_columbia, file_ir2rgb_ir_model_R_columbia) %>%
  rbind(process_mdT(file_folder_dbay, file_ir2rgb_ir_model_C_dbay, file_ir2rgb_ir_model_L_dbay, file_ir2rgb_ir_model_R_dbay)) %>%
  mutate(mdT_id = row_number())

# Merge data sets together
mnC_2_mnT <- merge_and_intersect(mnT, mnC, "minimum_distance") %>%
  rename(temp = image_name,
         mnC2mnT_distance = distance)
mnC_2_mdT <- merge_and_intersect(mdT, mnC, "minimum_distance")%>%
  rename(temp = image_name,
         mnC2mdT_distance = distance) 
mnC_2_mdC <- merge_and_intersect(mnC, mdC, "minimum_distance") %>%
  rename(temp = image_name,
         mnC2mdC_distance = distance) 
mnT_2_mdT <- merge_and_intersect(mnT, mdT, "minimum_distance") %>%
  rename(temp = image_name,
         mnT2mdT_distance = distance,
         mdT_id_temp = mdT_id)
mnT_2_mdC <- merge_and_intersect(mnT, mdC, "minimum_distance") %>%
  rename(temp = image_name,
         mnT2mdC_distance = distance,
         mdC_id_temp = mdC_id)
mdT_2_mdC <- merge_and_intersect(mdT, mdC, "minimum_distance") %>%
  rename(temp = image_name,
         mdT2mdC_distance = distance,
         mdC_id_temp = mdC_id)

# Create final summary dataset
combined <- mnC %>%
  select(mnC_id, mnC_image_name) %>%
  rename(image_name = mnC_image_name) %>%
  full_join(mnC_2_mnT, by = "mnC_id") %>%
    mutate(image_name = ifelse(is.na(image_name), temp, image_name)) %>%
    select(-temp) %>%
  full_join(mnC_2_mdT, by = "mnC_id") %>%
    mutate(image_name = ifelse(is.na(image_name), temp, image_name)) %>%
    select(-temp) %>%
  full_join(mnC_2_mdC, by = "mnC_id") %>%
    mutate(image_name = ifelse(is.na(image_name), temp, image_name)) %>%
    select(-temp) %>%
  full_join(mnT_2_mdT, by = "mnT_id") %>%
    mutate(image_name = ifelse(is.na(image_name), temp, image_name),
           mdT_id = ifelse(is.na(mdT_id), mdT_id_temp, mdT_id)) %>%
    select(-temp, -mdT_id_temp) %>%
  full_join(mnT_2_mdC, by = "mnT_id") %>%
    mutate(image_name = ifelse(is.na(image_name), temp, image_name),
           mdC_id = ifelse(is.na(mdC_id), mdC_id_temp, mdC_id)) %>%
    select(-temp, -mdC_id_temp) %>%
  full_join(mdT_2_mdC, by = "mdT_id") %>%
    mutate(image_name = ifelse(is.na(image_name), temp, image_name),
           mdC_id = ifelse(is.na(mdC_id), mdC_id_temp, mdC_id)) %>%
  select(-temp, -mdC_id_temp) %>%
  select(image_name, mnC_id, mnT_id, mdC_id, mdT_id, 
         mnC2mnT_distance, mnC2mdC_distance, mnC2mdT_distance, mnT2mdC_distance, mnT2mdT_distance, mdT2mdC_distance) %>%
  left_join(unprocessed_rgb, by = "image_name") %>%
  left_join(mnC %>% select(mnC_id, mnC_detection_type), by = "mnC_id") %>%
  left_join(mnT %>% select(mnT_id, mnT_detection_type), by = "mnT_id") %>%
  left_join(mdC %>% select(mdC_id, mdC_detection_type), by = "mdC_id") %>%
  left_join(mdT %>% select(mdT_id, mdT_detection_type), by = "mdT_id") %>%
  mutate(survey_id = ifelse(grepl("fl09", image_name), "columbia", "dbay"))

rm(mnC_2_mnT, mnC_2_mdT, mnC_2_mdC, mnT_2_mdT, mnT_2_mdC, mdT_2_mdC)

summ <- combined %>%
  select(survey_id, image_name, unprocessed, mnC_id, mnT_id, mdC_id, mdT_id) %>%
  mutate(id = row_number()) %>%
  mutate(manual_color = ifelse(is.na(mnC_id), 0, 1),
         manual_thermal = ifelse(is.na(mnT_id), 0, 1),
         model_color = ifelse(is.na(mdC_id), 0, 1),
         model_thermal = ifelse(is.na(mdT_id), 0, 1)) %>%
  mutate(freq_all = rowSums(.[, c("manual_color", "manual_thermal", "model_color", "model_thermal")])) %>%
  mutate(count_methods = ifelse(manual_color == 1, "manual RGB. ", "")) %>%
  mutate(count_methods = ifelse(manual_thermal == 1, paste0(count_methods, "manual IR. "), count_methods)) %>%
  mutate(count_methods = ifelse(model_color == 1, paste0(count_methods, "model RGB. "), count_methods)) %>%
  mutate(count_methods = ifelse(model_thermal == 1, paste0(count_methods, "model IR. "), count_methods)) %>%
  mutate(count_methods_noModelRGB = gsub("model RGB. ", "", count_methods))

write.csv(summ, "C:\\skh\\LATTE_Evaluation_20221128_MatchedRecords.csv", row.names = FALSE)

summ_long <- summ %>%
  filter(is.na(unprocessed)) %>%
  select(survey_id, image_name, mnC_id, mnT_id, mdC_id, mdT_id) %>%
  pivot_longer(cols = c(mnC_id, mnT_id, mdC_id, mdT_id), names_to = "found", values_to = "count_identifer") %>%
  mutate(found = ifelse(found == "mdC_id", "model RGB",
                               ifelse(found == "mdT_id", "model IR",
                                      ifelse(found == "mnC_id", "manual RGB", "manual IR")))) %>%
  filter(!is.na(count_identifer))

summ_prop <- summ %>% 
  filter(is.na(unprocessed)) %>% 
  mutate(count_methods = factor(count_methods, levels = unique(sort(count_methods)))) %>%
  group_by(count_methods, survey_id) %>%
  count() %>%
  group_by(survey_id) %>%
  mutate(proportion = n/sum(n))

summ_prop_noModelRGB <- summ %>% 
  filter(is.na(unprocessed)) %>% 
  mutate(count_methods_noModelRGB = factor(count_methods_noModelRGB, levels = unique(sort(count_methods_noModelRGB)))) %>%
  group_by(count_methods_noModelRGB, survey_id) %>%
  count() %>%
  group_by(survey_id) %>%
  mutate(proportion = n/sum(n))

ONLYmnC <- summ %>%
  filter(is.na(unprocessed)) %>% 
  filter(is.na(mnT_id) & is.na(mdT_id)) %>%
  left_join(mnC, by = "mnC_id") %>%
  rename(average_x = mnC_average_x,
         average_y = mnC_average_y) %>%
  select(mnC_id, survey_id, average_x, average_y)

ONLYthermal <- summ %>%
  filter(is.na(unprocessed)) %>% 
  filter(is.na(mnC_id) & !is.na(mnT_id) & !is.na(mdT_id)) %>%
  left_join(mnT, by = "mnT_id") %>%
  rename(average_x = mnT_average_x,
         average_y = mnT_average_y) %>%
  select(mnT_id, mdT_id, survey_id, image_name, average_x, average_y) %>%
  rbind(summ %>%
    filter(is.na(unprocessed)) %>% 
    filter((is.na(mnC_id) & is.na(mdT_id))) %>%
    left_join(mnT, by = "mnT_id") %>%
    rename(average_x = mnT_average_x,
         average_y = mnT_average_y) %>%
    select(mnT_id, mdT_id, survey_id, image_name, average_x, average_y)) %>%
  rbind(summ %>%
    filter(is.na(unprocessed)) %>% 
    filter(is.na(mnC_id) & is.na(mnT_id)) %>%
    left_join(mdT, by = "mdT_id") %>%
    rename(average_x = mdT_average_x,
           average_y = mdT_average_y) %>%
    select(mnT_id, mdT_id, survey_id, image_name, average_x, average_y))
```

## Introduction

The purpose of this document is to support the evaluation of different methods for counting harbor seals at sites surveyed using the LATTE approach. The methods being evaluated are as follows (**reference name within document**):

-   Manual review using color imagery only (**manual RGB**)
-   Manual review using thermal and color imagery (**manual IR**) -- will not include any image pairs where the thermal image was NUC; *any harbor seals found in the color imagery only (marked as being off the thermal frame) are excluded from this summary document*
-   Detection model review of thermal and color imagery based on the Ice Seal Color detection model (**model RGB**) -- will not include any image pairs where the thermal image was NUC
-   Detection model review of thermal and color imagery based on the Ice Seal Thermal detection model (**model IR**)-- will not include any image pairs where the thermal image was NUC
-   Detection model review of color imagery based on the Ice Seal Color detection model -- will include any image pairs where the thermal image was NUC. This model output was only evaluated for one of the sites and has a high number of false positives, so it has been excluded from this initial review. This information will be used to help identify a threshold for detection values and may be considered as possibility for streamlining the processing of color images where a thermal image is available.

## Methods

To conduct this evaluation, I matched the harbor seals from each of the counting methods to one another based on their bounding box locations to determine by which method(s) the seal was detected.

-   For each method, I calculated the mid-point of each bounding box for each seal.
-   For each pair of methods (for a total of six combinations), I merged the pair of data sets together based on image name, which resulted in all harbor seals within each frame from one method being matched to all harbor seals within the same frame for the other method. To find the matching seals, I applied a two-step approach. After this process was complete, what remained were the records that matched between the two files.
    -   First, I looked for matched records where the bounding boxes overlapped; if they did not overlap, that possible match was eliminated from further consideration.
    -   Second, I calculated the distances between the remaining matches and selected the minimum distance (within 50 pixels) for each harbor seal. Seals largely seemed to be \~80-100 pixels tall and wide, so this felt like a reasonable assumption for a maximum distance between midpoints for the same harbor seal across different frames. This allowance is important because of the application of the transformation to the color and thermal image pair. The transformation is used to project bounding boxes between color and thermal imagery based on their known alignment, and it works quite well, though it's not exact.
-   After all combinations of data sets were matched and because we could not assume that one method captured all the seals within the imagery, I merged all the data together to generate a final data set of all seals that were detected across the four methods.

\newpage

## Data Overview

Data were processed for two sites: Disenchantment Bay (9/4/2020; dbay) and Columbia Glacier (9/9/2022; columbia).

-   Across the two data sets, a total of `r nrow(summ)` harbor seals were detected using the different methods, `r nrow(summ %>% filter(survey_id == 'dbay'))` at Disenchantment Bay and `r (nrow(summ %>% filter(survey_id == 'columbia')))` at Columbia Glacier.
-   Across both sites, harbor seals were detected on a total of `r length(unique(summ$image_name))` images.
-   Of the color images where harbor seals were manually reviewed, `r nrow(summ %>% filter(unprocessed == 'TRUE') %>% select(image_name) %>% unique())` images (and `r nrow(summ %>% filter(unprocessed == 'TRUE'))` corresponding harbor seals) did not have an associated thermal image as a result of the camera going through its calibration (commonly referred to as NUC). Since harbor seals could only be found on those frames during the manual color review, those images have been excluded from further data summaries.

## Comparison of Methods

The following tables and figures represent different viewpoints of the count data to help understand the differences in detection by each method, excluding any harbor seals that were detected on color frames where there was not an accompanying thermal image.

### Processing Time

Before getting into the counts, it is also important to consider the amount of time it takes to review these imagery. A couple important observations:

-   The manual review methods took *substantially* longer to review than the model review methods.

-   Some of the differences in manual review time are explained by individual review methods (especially for the manual IR review as documented within the tracking spreadsheet), issues with DIVE, and challenges with image quality.

| Detection Method            | Columbia Glacier | Disenchantment Bay |
|-----------------------------|------------------|--------------------|
| manual RGB (current method) | 31               | 17                 |
| manual IR                   | 10.5             | 22                 |
| model RGB                   | 3.25             | 1.25               |
| model IR                    | 6                | 1.5                |

: The number of hours required to process each detection data set.

\newpage

### Counts by Method and Site

To start at highest level, the following figure represents the total number of seals detected by each counting method.

-   For both sites, the two IR methods were similar to or better than the manual RGB method.
-   For both sites, the model IR method outperformed the model RGB method.
-   For Columbia, the most seals were detected using the manual IR review.
-   For Disenchantment Bay, the most seals were detected using the manual RGB review.

```{r counts_by_method, fig.height = 4, fig.cap = "The total number of harbor seals detected using each counting method by Survey ID."}
ggplot(data = summ_long, aes(x = survey_id, fill = found)) +
  geom_bar(position = "dodge") + 
  scale_fill_brewer(palette = "BrBG") + 
  guides(fill = guide_legend(title = "Counting Method")) +
  xlab("Survey ID") +
  ylab("# of Harbor Seals")
```

\newpage

### Proportion of Harbor Seals Detected

To drill down into the data a bit more, the following figure represents the proportion of harbor seals (by Survey ID) that were detected by 1, 2, 3 or 4 (all) of the counting methods. This figure does not break out by which method each harbor seal was detected (that will come later).

-   For both sites, approximately 90% of harbor seals were detected by 3 or 4 (all) methods. This is fantastic!
-   At Columbia Glacier, over 65% of harbor seals were detected by all 4 methods, and at Disenchantment Bay, almost 50% of harbor seals were detected by all 4 methods.
-   Relatively few seals were detected by only one method, especially at Columbia Glacier.

```{r proportion_by_method, fig.height = 4, fig.cap = "The proportion of harbor seals detected by 1, 2, 3 or 4 (all) methods."}
ggplot(data = summ %>% filter(is.na(unprocessed)), aes(y = freq_all, x = survey_id, fill = as.character(freq_all))) + 
  geom_bar(stat = "identity", width = 0.5, position = "fill") + 
  scale_fill_brewer(palette = "BuGn") + 
  guides(fill = guide_legend(title = "# of Methods")) +
  xlab("Survey ID") +
  ylab("Proportion of Harbor Seals")
```

\newpage

### Counts by Method Combinations

The figure help to tease out how many seals were detected by different method combinations for each survey. At a minimum, each harbor seal must have been detected by at least one method, and at most, a harbor seal could have been detected by all four methods. Most important observation:

-   No seals were detected *only* by the model RGB detection method.

```{r count_by_method_combo, fig.height = 4, fig.cap = "The count of harbor seals within each survey that were detected by the combination of detection methods."}
# ggplot(data = summ_prop, aes(x = n, y = count_methods, fill = survey_id)) +
#   geom_bar(position = 'dodge', stat = 'identity') +
#   scale_fill_brewer(palette = "Dark2") + 
#   guides(fill = guide_legend(title = "Survey ID")) +
#   xlab("Count of Harbor Seals within Survey") +
#   ylab("Combinations of Detection Methods")

ggplot(data = summ_prop, aes(y = n, x = survey_id, fill = count_methods)) + 
  geom_bar(stat = "identity", width = 0.5, position = "dodge") + 
  scale_fill_brewer(palette = "BrBG") + 
  scale_y_break(c(100, 270), scales = 0.25) + 
  guides(fill = guide_legend(title = "Combinations of Methods")) +
  xlab("Survey ID") +
  ylab("Count of Harbor Seals")
```

\newpage

### Counts by Method Combinations (excluding model RGB)

Because the model RGB was the least successful method and because no seals were detected by that method alone the two previous figures, it will not be a method that we would solely rely on for counting data (in its current existence), so it has been excluded from the remaining figures. This model (or some future iteration of it) *could* be used to supplement the manual RGB review (depending on how we decide to process data for 2020 and 2021), but for the current purposes, the remaining summaries exclude this data set.

-   At Columbia Glacier:

    -   Approximately 77% of harbor seals were detected by all three detection methods.

    -   The manual and model IR reviews detected approximately 93% of harbor seals detected at the site (missed n=37 harbor seals). These can likely be explained by areas in the color images that are not reflected in this thermal images, and this will be explored in subsequent figures.

    -   Approximately 10% (n=50) harbor seals were detected by both manual review methods and *missed* by both model review methods.

    -   The IR model review detected two harbor seals that were missed by the manual reviews.

-   At Disenchantment Bay:

    -   Approximately 82% of harbor seals were detected by all three detection methods.

    -   The manual and model IR reviews detected approximately 88% of harbor seals detected at the site and detected one harbor seal that was missed by the manual color review.

```{r count_by_method_combo_noModelRGB, fig.height = 4, fig.cap = "The count of harbor seals within each survey that were detected by the combination of detection methods(excluding model RGB detection method)."}
# ggplot(data = summ_prop, aes(x = n, y = count_methods, fill = survey_id)) +
#   geom_bar(position = 'dodge', stat = 'identity') +
#   scale_fill_brewer(palette = "Dark2") + 
#   guides(fill = guide_legend(title = "Survey ID")) +
#   xlab("Count of Harbor Seals within Survey") +
#   ylab("Combinations of Detection Methods")

ggplot(data = summ_prop_noModelRGB, aes(y = n, x = survey_id, fill = count_methods_noModelRGB)) + 
  geom_bar(stat = "identity", width = 0.5, position = "dodge") + 
  scale_fill_brewer(palette = "BrBG") + 
  scale_y_break(c(75, 350), scales = 0.25) + 
  guides(fill = guide_legend(title = "Combinations of Methods")) +
  xlab("Survey ID") +
  ylab("Count of Harbor Seals")
```

```{r proportion_by_method_combo_noModelRGB, fig.height = 4, fig.cap = "The proportion of harbor seals within each survey that were detected by the combination of detection methods."}
# ggplot(data = summ_prop, aes(x = proportion, y = count_methods, fill = survey_id)) +
#   geom_bar(position = 'dodge', stat = 'identity') +
#   scale_fill_brewer(palette = "Dark2") + 
#   guides(fill = guide_legend(title = "Survey ID")) +
#   xlab("Proportion of Harbor Seals within Survey") +
#   ylab("Combinations of Detection Methods")

ggplot(data = summ_prop_noModelRGB, aes(y = proportion, x = survey_id, fill = count_methods_noModelRGB)) + 
  geom_bar(stat = "identity", width = 0.5, position = "fill") + 
  scale_fill_brewer(palette = "BrBG") + 
  guides(fill = guide_legend(title = "Combinations of Methods")) +
  xlab("Survey ID") +
  ylab("Proportion of Harbor Seals")
```

\newpage

\newpage

## Evaluation of Missed Harbor Seals

To help identify if there are any general patterns in where missed seals were located within frames and to focus any further review of detections to resolve why they were missed, the following two figures were created.

The first figure depicts the locations within the color frame where harbor seals were not detected within the thermal imagery.

-   Most of the missed harbor seals were located on the inner and outer edges of the frames. The footprint for the color images was larger than that of the thermal images, so there are areas within the color images that the associated thermal images do not cover. These areas vary a bit camera-to-camera, but generally fall along the edges of the color frames. The locations where *most* of the harbor seals that were missed in the thermal images seem likely to fall in that area where the images do not overlap.

```{r missed_seals_thermal, fig.height = 4, fig.cap = "The location of harbor seals detected within the color frames that were not detected within the thermal frames."}
ggplot(data = ONLYmnC, aes(x = average_x, y = average_y)) +
  geom_point(aes(color = survey_id)) +
  scale_y_reverse() +
  guides(fill = guide_legend(title = "Survey ID")) +
  xlab("Locations of Missed Harbor Seals") +
  ylab("")
```

\newpage

The second figure depicts the locations within the thermal frame where harbor seals were not detected within the color imagery.

-   The missed harbor seals were distributed throughout the thermal images, which suggests there was not a systematic bias in missed seals.
-   `r nrow(ONLYthermal)` harbor seals were missed on `r length(unique(ONLYthermal$image_name))` frames across both survey areas.

```{r missed_seals_color, fig.height = 4, fig.cap = "The location of harbor seals detected within the thermal frames that were not detected within the color frames."}
ggplot(data = ONLYthermal, aes(x = average_x, y = average_y)) +
  geom_point(aes(color = survey_id)) +
  scale_y_reverse() +
  xlab("Locations of Missed Harbor Seals") +
  ylab("")
```

\newpage

## Known Data Caveats or Potential Issues

In conjunction with our understanding of how effective the different counting methods are for detecting harbor seals, it is important to consider a number of known caveats or potential issues in the data/images themselves.

-   **Unpaired color and thermal frames as a result of thermal camera NUC rates**: We observed in the field a higher than expected rate of thermal camera NUC while flying at LATTE sites. This is likely due to fluctuating temperatures at the sites when transitioning from being over the glacier to being over open water or other temperature variances at the site. For these instances, we will not have associated thermal images for all the color images collected at a site. Possible ways to handle this circumstance:
    -   *Manually count the color image* (can possibly be done in Seal-TK along with a color-thermal review, if we went that route, so it wouldn't necessarily be an extra step in the process)
    -   *Exclude color image from the survey altogether* (the occurrence of missing thermal images is spatially correlated, so this might not be the best option)
-   **Color image loss**: Based on the estimates of frame drop rates throughout the glacial imagery collected, the loss of color frames is expected to be quite low, *but* there is the possibility that we have occasional cases thermal frames not having an associated color image. Possible ways to handle this circumstance:
    -   *Review thermal image for possible seals* (would have to designate a harbor seal based on thermal imagery only)
    -   *Drop the thermal images from review* (would result in a gap in coverage at the site)
-   **Areas in color and thermal images where there is not overlap**: For a couple of reasons, the area captured in the color and thermal images are not completely aligned (because of differences in size of area covered and a bit of an offset between some of the camera angles). Possible ways to handle this circumstance:
    -   *Count only seals where thermal and color images overlap* (can easily track what area was reviewed because the footprints can accurately represent the overlapping zones)
    -   *Count all seals on color images, which means thermal images will supplement color images where they are available and color images will be manually reviewed (on all images) where there is no image overlap* (would require additional work to review the areas where there is no corresponding thermal coverage and combines two different counting/detection methods; maybe consider labeling seals differently to track how they were detected)
-   **Side-to-side overlap in the color images**: Due to an offset in the camera mount, the center and left color images overlap. Will need to develop code to identify these duplicates.
-   **Image quality**: The ease with which harbor seals can be confidently determined is affected by color image quality. In places where there are thermal data to supplement, it is easier to detect warm seals. In places where there are not thermal data or the color images are particularly of poor quality, this will affect our counts.
-   **Issues using DIVE software for manual review**: Given some of the issues that John experienced while using DIVE, it is possible that the manual RGB count at Columbia is lower than would be otherwise expected because frames were skipped over. If we chose a fully manual approach using DIVE, we will need to identify some methods for this continuing to be an issue. If we supplement with thermal images, we will be using Seal-TK, and this won't be an issue.
-   **Differences in how thermal-color manual review was completed**: We marked in the datasheet (slightly) different ways Gavin and I reviewed the thermal-color manual review. I'm not sure if or how these differences would affect the final counts for each site.
-   **Observer caveats**: to discuss at meeting...ahead of time, think about anything else that you experienced while reviewing model detection outputs or going through images that could have had an effect on the output of this evaluation.

## Next Steps

-   Evaluate another site?
-   Provide data exports of existing data sets, missed seals based on methods, etc. to help continue to evaluate results from this analysis?
-   Identify the best method (or combination of methods) for counting LATTE sites
-   Conversation with Jay?
-   Data processing steps (SKH):
    -   Must be done before counting can start:

        -   Updates to code for preparing data for counting (\~4 hours)
        -   Reorganize on the LAN and re-import 2020 data (so that the image lists reflect the corrected network paths) (\~12 hours...the import takes some time)
        -   Set up Annotations folder for processing 2020 and 2021 glacial LATTE sites (separate folder for each year's data) (\~4 hours)
        -   Clean up counts and associated files for Disenchantment Bay and Columbia, so these sites do not need to be re-counted (\~2 hours)
        -   Update data processing steps in Glacial and Annotations Access front-ends and other data processing documentation for clear steps/tracking/processing (\~2 hours)

    -   Can be done after counting has started:

        -   Develop code for importing annotations into surv_pv_gla schema in pep database
        -   Develop shell code (or process using post-processing script) to generate output of harbor seal locations within habitat (with CLC)
        -   Develop code for handling side-to-side or double-coverage overlap areas
        -   Develop code for providing Jay with the final counts and necessary data for him to return count estimates

Thank you for reading! :)
